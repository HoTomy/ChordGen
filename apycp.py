# -*- coding: utf-8 -*-
"""ApyCP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IAyO10gLrf7E4UcOZmgszEOmoiUnr_vU

**Install Music 21**
"""

pip install music21

"""**Install Pretty MIDI**"""

pip install pretty_midi

"""**Install MIDO**"""

pip install mido

"""**Import Suitable Library**"""

import pretty_midi
import numpy as np
from music21 import converter

"""**Import music 21 and json library and link to Google Drive**"""

# Import libraries
import music21
import json
from google.colab import drive

# Mount Google Drive
drive.mount('/content/drive')

"""**Import Midi file**"""

# Directory where the MIDI files are located
midi_dir = "/content/drive/MyDrive/midi/"

for i in range(70):
midi_file_path = "/content/drive/MyDrive/midi/uploaded.mid"
midi_data = converter.parse(midi_file_path)

"""**Deteminate Number of Bar**"""

import music21

# Get the time signature of the MIDI file (assuming a single time signature throughout)
time_signature = midi_data.recurse().getElementsByClass(music21.meter.TimeSignature)[0]

note_duration = time_signature.beatDuration.quarterLength
# Get the duration of one bar in the MIDI file
bar_duration = time_signature.barDuration.quarterLength

# Get the total duration of the MIDI file
total_duration = midi_data.duration.quarterLength

# Calculate the number of bars in the MIDI file
num_bars = int(total_duration / bar_duration)

print(f"Number of bars: {num_bars}")

"""**Found Out the Music Note and Its Pattens**"""

import mido

# Get second track
track = midi_data.tracks[1]

# Loop over track events
for event in track:
    # Check if event is a note_on event
    if event.type == 'note_on':
        # Get note pitch (MIDI note number)
        note_pitch = event.note
        # Convert MIDI note number to frequency
        frequency = 2 ** ((note_pitch - 69) / 12) * 440
        time_signature = midi_data.recurse().getElementsByClass(music21.meter.TimeSignature)[0]
         # Print note pitch and frequency
        print(f'Note pitch: {note_pitch}, Frequency: {frequency:.2f} Hz')

"""**Get the Music Notes from MIDI**"""

import mido
from mido import MidiFile

# Data structure to store the notes
notes_by_bar = {}

# Iterate through the MIDI tracks and messages
for i, track in enumerate(midi_data.tracks):
    current_time = 0
    current_bar = 0
    notes_by_bar[current_bar] = []

    for msg in track:
        if msg.type == 'note_on':
            if msg.time > 0:
                current_time += msg.time
            current_bar = current_time // mid.ticks_per_beat // 4  # Assuming 4/4 time signature
            note_pitch = msg.note
            note_duration = msg.time
            notes_by_bar[current_bar].append((note_pitch, note_duration))

# Print the notes by bar
for bar, notes in notes_by_bar.items():
    print(f"Bar {bar}:")
    for note in notes:
        pitch, duration = note
        print(f"Pitch: {pitch}, Duration: {duration}")
    print()

"""**Define the equations and get extracted chords by bar**"""

import numpy as np

import mido
from collections import Counter

# Define the equations
equations = np.array([
    [9, 3, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0],   # CMajor
    [6, 0, 4, 0, 0, 2, 0, 3, 0, 0, 0, 0],   # C#Major
    [0, 6, 1, 0, 4, 0, 0, 3, 0, 0, 0, 0],   # DMajor
    [1, 1, 0, 0, 5, 0, 5, 0, 0, 1, 0, 0],   # D#Major
    [2, 1, 0, 1, 3, 1, 0, 3, 0, 1, 2, 0],   # EMajor
    [1, 1, 0, 0, 0, 5, 2, 0, 0, 6, 0, 1],   # FMajor
    [1, 2, 0, 2, 0, 3, 0, 0, 2, 0, 0, 2],   # F#Major
    [1, 1, 2, 0, 0, 0, 0, 5, 0, 0, 5, 0],   # GMajor
    [4, 0, 0, 3, 0, 2, 0, 0, 0, 0, 0, 5],   # G#Major
    [5, 1, 2, 0, 0, 0, 0, 6, 0, 2, 0, 0],   # AMajor
    [5, 0, 0, 1, 0, 0, 0, 0, 1, 0, 7, 0],   # A#Major
    [0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 6],   # BMajor
    [5, 1, 3, 2, 1, 3, 1, 0, 1, 0, 1, 0],   # CMinor
    [8, 0, 0, 4, 0, 3, 0, 0, 0, 1, 0, 0],   # C#Minor
    [0, 5, 2, 0, 4, 0, 0, 1, 1, 0, 2, 0],   # DMinor
    [1, 2, 0, 2, 0, 2, 1, 0, 0, 2, 0, 2],   # D#Minor
    [1, 1, 0, 1, 4, 1, 1, 0, 1, 0, 3, 0],   # EMinor
    [2, 0, 6, 0, 5, 0, 0, 2, 0, 0, 0, 0],   # FMinor
    [2, 1, 0, 2, 0, 1, 4, 0, 1, 1, 0, 1],   # F#Minor
    [1, 1, 2, 0, 4, 2, 0, 0, 2, 2, 0, 0],   # GMinor
    [2, 2, 0, 0, 1, 0, 7, 0, 1, 3, 0, 0],   # G#Minor
    [3, 1, 0, 2, 0, 0, 0, 5, 0, 2, 0, 2],   # AMinor
    [1, 4, 1, 0, 1, 0, 0, 2, 5, 0, 0, 6],   # A#Minor
    [0, 3, 1, 1, 0, 1, 2, 0, 2, 5, 2, 0]    # BMinor
])

chord_names = [
    'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'Cm', 'C#m', 'Dm', 'D#m', 'Em', 'Fm', 'F#m', 'Gm', 'G#m', 'Am', 'A#m', 'Bm'
]


# Set up the least squares problem
A = equations[:, :-1]  # Coefficient matrix
b = equations[:, -1]   # Constants vector

# Solve the least squares problem
coefficients, _, _, _ = np.linalg.lstsq(A, b, rcond=None)

# Define the notes in order
notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']

# Function to determine the bar's chord
def determine_chord(bar_notes):
    # Calculate the sum of squares for each chord
    sums_of_squares = []
    for i in range(len(notes)):
        chord_notes = np.dot(coefficients, equations[i, :-1])
        sum_of_squares = np.sum((bar_notes - chord_notes) ** 2)
        sums_of_squares.append(sum_of_squares)

    # Determine the chord with the smallest sum of squares
    idx = np.argmin(sums_of_squares)
    return notes[idx]


    for bar, notes in notes_by_bar.items():
      for msg in midi_data:
        if msg.type == 'note_on':
          notes.append(msg.note)
        return notes
        pitch, duration = note
        scores = {chord: evaluate_bar(notes, chords[chord]) for chord in chords}
          return min(scores, key=scores.get)
          if min(scores, key=scores.get) >40:
            determine_chord(bar_notes/2):
            # Calculate the sum of squares for each chord again
            sums_of_squares = []
            if i % 2 = 0
              i = +1
              for i in range(len(notes)):
                chord_notes = np.dot(coefficients, equations[i, :-1])
                sum_of_squares = np.sum((bar_notes - chord_notes) ** 2)
              sums_of_squares.append(sum_of_squares)
          extracted_chords = determine_chord(notes)
    # Determine the chord with the smallest sum of squares
    idx = np.argmin(sums_of_squares)
    return notes[idx]

          else:
          extracted_chords = determine_chord(notes)

"""**Define Chord Progression**"""

# Define the 12 common chord progressions
cp1 = ['I', 'IV', 'V', 'I']
cp2 = ['I', 'vi', 'IV', 'V']
cp3 = ['I', 'IV', 'vi', 'V']
cp4 = ['vi', 'IV', 'I', 'V']
cp5 = ['I', 'V', 'vi', 'IV']
cp6 = ['IV', 'I', 'V', 'iv']
cp7 = ['IV', 'I', 'vi', 'V']
cp8 = ['I', 'iii', 'vi', 'IV']
cp9 = ['I', 'IV', 'vi', 'V']
cp10 = ['vi', 'IV', 'I', 'V']
cp11 = ['I', 'V', 'vi', 'IV']
cp12 = ['IV', 'ii', 'V', 'I']

# Create a dictionary to map each chord progression to its corresponding list of chords
chord_progressions = {
    'cp1': cp1,
    'cp2': cp2,
    'cp3': cp3,
    'cp4': cp4,
    'cp5': cp5,
    'cp6': cp6,
    'cp7': cp7,
    'cp8': cp8,
    'cp9': cp9,
    'cp10': cp10,
    'cp11': cp11,
    'cp12': cp12
}

"""**Define Distance Function**"""

def chord_progression_distance(chord, chord_progressions):
    min_distance = float('inf')
    for progression in chord_progressions:
        distance = sum([1 for i, c in enumerate(chord) if c != progression[i]]) / len(chord)
        index_different_chord = -1
          for i in range(len(chords_extracted)):
          if chords_extracted[i] != chords_progression[i]:
            index_different_chord = i
        if distance < min_distance:
            min_distance = distance
    return min_distance
    final_progression = [cp1, cp2, cp3, cp4, cp5, cp6, cp7, cp8, cp9, cp10, cp11, cp12][min_distance.index(min_distance))]

"""**Get the Generated Chord**"""

score_extracted = min(scores, key=scores.get)
score_progression = {chord: index_different_chord for final_progression}
weight = min_distance

weighted_score_progression = score_progression * weight

if weighted_score_progression < score_extracted:
    generated_chords = chords_progression
    generated_score = weighted_score_progression
else:
    generated_chords = chords_extracted
    generated_chords = score_extracted

from os import major
from music21 import converter, chord
import json
from google.colab import drive

# Mount Google Drive
drive.mount('/content/drive')
from google.colab import drive

# Get the key
key = midi_data.analyze('key')

# Print the key's name and mode
print(key.name, key.mode)

# Extract chord names
chord_names = []
cfn = []
#for element in midi_file2.recurse():
for i, element in enumerate(midi_data.recurse()):
  if i % 2 == 0:
    chord_names.append(element.generated_chords(i+1))
  else:
    chord_names.append(element.generated_chords(i))

# Print chord names
for name in chord_names:
    print(name)

# Save chord names as JSON
drive.mount('/content/gdrive')
json_data = {"key":key.name, "chords": chord_names}
with open('/content/gdrive/MyDrive/chords.json', 'w') as f:
    json.dump(json_data, f)

# Load the JSON data from a file
with open('/content/gdrive/MyDrive/chords.json') as file:
    data = json.load(file)

# Extract the chords list from the data
chords = data['chords']

# Convert the chords list to a JSON string
json_chords = json.dumps(chords)

# Print the JSON string
print(json_chords)